{"version":3,"sources":["../node_modules/idb-keyval/dist/idb-keyval.mjs","../src/lib/sw.js"],"names":["Store","[object Object]","dbName","storeName","this","_dbp","Promise","resolve","reject","openreq","indexedDB","open","onerror","error","onsuccess","result","onupgradeneeded","createObjectStore","type","callback","then","db","transaction","oncomplete","onabort","objectStore","store","getDefaultStore","get","key","req","_withIDBStore","set","value","put","serviceWorkerArchitecture","normalizeIndexCacheKeyPlugin","cacheKeyWillBeUsed","request","mode","url","endsWith","importScripts","replacingPreviousServiceWorker","self","addEventListener","event","registration","active","waitUntil","skipWaiting","p","async","previousArchitecture","idb.get","undefined","console","debug","clients","claim","matchAll","includeUncontrolled","map","client","navigate","idb.set","workbox","googleAnalytics","initialize","routing","registerRoute","strategies","StaleWhileRevalidate","cacheName","CacheFirst","plugins","cacheableResponse","Plugin","statuses","expiration","maxAgeSeconds","maxEntries","precaching","precacheAndRoute","manifest","contentPageRe","RegExp","untrailedContentPageRe","u","URL","exec","pathname","location","host","cacheKey","getCacheKeyForURL","caches","match","fetch","e","headers","Headers","append","Response","status","respondWith","setCatchHandler","destination","ignoreSearch"],"mappings":"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","sourcesContent":["class Store {\r\n    constructor(dbName = 'keyval-store', storeName = 'keyval') {\r\n        this.storeName = storeName;\r\n        this._dbp = new Promise((resolve, reject) => {\r\n            const openreq = indexedDB.open(dbName, 1);\r\n            openreq.onerror = () => reject(openreq.error);\r\n            openreq.onsuccess = () => resolve(openreq.result);\r\n            // First time setup: create an empty object store\r\n            openreq.onupgradeneeded = () => {\r\n                openreq.result.createObjectStore(storeName);\r\n            };\r\n        });\r\n    }\r\n    _withIDBStore(type, callback) {\r\n        return this._dbp.then(db => new Promise((resolve, reject) => {\r\n            const transaction = db.transaction(this.storeName, type);\r\n            transaction.oncomplete = () => resolve();\r\n            transaction.onabort = transaction.onerror = () => reject(transaction.error);\r\n            callback(transaction.objectStore(this.storeName));\r\n        }));\r\n    }\r\n}\r\nlet store;\r\nfunction getDefaultStore() {\r\n    if (!store)\r\n        store = new Store();\r\n    return store;\r\n}\r\nfunction get(key, store = getDefaultStore()) {\r\n    let req;\r\n    return store._withIDBStore('readonly', store => {\r\n        req = store.get(key);\r\n    }).then(() => req.result);\r\n}\r\nfunction set(key, value, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.put(value, key);\r\n    });\r\n}\r\nfunction del(key, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.delete(key);\r\n    });\r\n}\r\nfunction clear(store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.clear();\r\n    });\r\n}\r\nfunction keys(store = getDefaultStore()) {\r\n    const keys = [];\r\n    return store._withIDBStore('readonly', store => {\r\n        // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\r\n        // And openKeyCursor isn't supported by Safari.\r\n        (store.openKeyCursor || store.openCursor).call(store).onsuccess = function () {\r\n            if (!this.result)\r\n                return;\r\n            keys.push(this.result.key);\r\n            this.result.continue();\r\n        };\r\n    }).then(() => keys);\r\n}\n\nexport { Store, get, set, del, clear, keys };\n","// Architecture revision of the Service Worker. If the previously saved revision do// Architecture revision of the Service Worker. If the previously saved revision doesn't match,\n// then this will cause clients to be aggressively claimed and reloaded on install/activate.\n// Used when the design of the SW changes dramatically, e.g. from DevSite to v2.\nconst serviceWorkerArchitecture = \"v2\";\n\nconst normalizeIndexCacheKeyPlugin = {\n  cacheKeyWillBeUsed({request, mode}) {\n    // Take advantage of Workbox's built-in handling of .../index.html routes and ensure that its\n    // cache keys always include it. (e.g., requests for foo/ will load foo/index.html: but\n    // foo/index.html will not load foo/).\n    if (request.url.endsWith(\"/\")) {\n      return request.url + \"index.html\";\n    }\n    return request;\n  },\n};\n\nimport * as idb from \"idb-keyval\";\nimport manifest from \"cache-manifest\";\n\nimportScripts(\n  \"https://storage.googleapis.com/workbox-cdn/releases/4.3.1/workbox-sw.js\",\n);\n\nlet replacingPreviousServiceWorker = false;\n\nself.addEventListener(\"install\", (event) => {\n  // This is non-null if there was a previous Service Worker registered. Record for \"activate\", so\n  // that a lack of current architecture can be seen as a reason to reload our clients.\n  if (self.registration.active) {\n    replacingPreviousServiceWorker = true;\n  }\n\n  event.waitUntil(self.skipWaiting());\n});\n\nself.addEventListener(\"activate\", (event) => {\n  const p = Promise.resolve().then(async () => {\n    const previousArchitecture = await idb.get(\"arch\");\n    if (previousArchitecture === undefined && replacingPreviousServiceWorker) {\n      // We're replacing a Service Worker that didn't have architecture info. Force reload.\n    } else if (\n      !replacingPreviousServiceWorker ||\n      previousArchitecture === serviceWorkerArchitecture\n    ) {\n      // The architecture didn't change (or this is a brand new install), don't force a reload,\n      // upgrades will happen in due course.\n      return;\n    }\n    console.debug(\n      \"web.dev SW upgrade from\",\n      previousArchitecture,\n      \"to arch\",\n      serviceWorkerArchitecture,\n    );\n\n    await self.clients.claim();\n\n    // Reload all open pages (includeUncontrolled shouldn't be needed as we've _just_ claimed\n    // clients, but include it anyway for sanity).\n    const windowClients = await self.clients.matchAll({\n      includeUncontrolled: true,\n      type: \"window\",\n    });\n\n    // It's impossible to 'await' this navigation because this event would literally be blocking\n    // our fetch handlers from running. These navigates must be 'fire-and-forget'.\n    windowClients.map((client) => client.navigate(client.url));\n\n    await idb.set(\"arch\", serviceWorkerArchitecture);\n  });\n  event.waitUntil(p);\n});\n\nworkbox.googleAnalytics.initialize();\n\n// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy.\nworkbox.routing.registerRoute(\n  /^https:\\/\\/fonts\\.googleapis\\.com/,\n  new workbox.strategies.StaleWhileRevalidate({\n    cacheName: \"google-fonts-stylesheets\",\n  }),\n);\n\n// Cache the underlying font files with a cache-first strategy for 1 year.\nworkbox.routing.registerRoute(\n  /^https:\\/\\/fonts\\.gstatic\\.com/,\n  new workbox.strategies.CacheFirst({\n    cacheName: \"google-fonts-webfonts\",\n    plugins: [\n      new workbox.cacheableResponse.Plugin({\n        statuses: [0, 200],\n      }),\n      new workbox.expiration.Plugin({\n        maxAgeSeconds: 60 * 60 * 24 * 365,\n        maxEntries: 30,\n      }),\n    ],\n  }),\n);\n\nworkbox.precaching.precacheAndRoute(manifest);\n\n/**\n * Match \"/foo-bar/ \"and \"/foo-bar/as/many/of-these-as-you-like/\" (with optional trailing\n * \"index.html\"), normal page nodes for web.dev.\n */\nconst contentPageRe = new RegExp(\"/([\\\\w-]+/)*(|index.html)$\");\n\n/**\n * Match \"/foo-bar\" and \"/foo-bar/as-many/but/no/trailing/slash\" (but not \"/foo/bar/index.html\").\n * This roots at the left \"/\" as it's not given to Workbox, which does this for us.\n */\nconst untrailedContentPageRe = new RegExp(\"^(/[\\\\w-]+)+$\");\n\n/**\n * Send normal nodes to cache first.\n */\nworkbox.routing.registerRoute(\n  contentPageRe,\n  new workbox.strategies.StaleWhileRevalidate({\n    plugins: [normalizeIndexCacheKeyPlugin],\n  }),\n);\n\n/**\n * Cache images that aren't included in the original manifest, such as author profiles.\n */\nworkbox.routing.registerRoute(\n  new RegExp(\"/images/.*\"),\n  new workbox.strategies.StaleWhileRevalidate(),\n);\n\n/**\n * Untrailed requests are network-only, but with a fallback to redirecting to the same page with a\n * trailing slash.\n */\nself.addEventListener(\"fetch\", (event) => {\n  const u = new URL(event.request.url);\n  if (\n    !untrailedContentPageRe.exec(u.pathname) ||\n    self.location.host !== u.host\n  ) {\n    return;\n  }\n\n  const p = Promise.resolve().then(async () => {\n    // First, check if there's actually something in the cache already.\n    const cacheKey = workbox.precaching.getCacheKeyForURL(\n      u.pathname + \"/index.html\",\n    );\n    const cached = await caches.match(cacheKey);\n    if (!cached) {\n      // If there's not, then try the network.\n      try {\n        return await fetch(event.request);\n      } catch (e) {\n        // If fetch fails, just redirect below.\n      }\n    }\n\n    // Either way, redirect to the updated Location.\n    const headers = new Headers();\n    headers.append(\"Location\", event.request.url + \"/\");\n    const redirectResponse = new Response(\"\", {\n      status: 301,\n      headers,\n    });\n    return redirectResponse;\n  });\n\n  event.respondWith(p);\n});\n\nworkbox.routing.setCatchHandler(async ({event}) => {\n  // Destination is set by loading this content normally; it's not set for fetch(), so look for our\n  // custom header.\n  const isDocumentRequest =\n    event.request.destination === \"document\" ||\n    event.request.headers.get(\"X-Document\");\n  if (isDocumentRequest) {\n    const cacheKey = workbox.precaching.getCacheKeyForURL(\n      \"/offline/index.html\",\n    );\n    if (!cacheKey) {\n      // This occurs in development when the offline page is in the runtime cache.\n      return caches.match(\"/offline/index.html\", {ignoreSearch: true});\n    }\n    return caches.match(cacheKey);\n  }\n});\n"]}